#include <Arduino.h>

#include <Wire.h>
//---------------------------------------
#include "conf_app.h"

#include "pins.h"
#include "reg.h"
#include "port.h"
#include "fifo.h"
#include "keyboard.h"


#define DEBUG_UART

HardwareSerial Serial1(PA10, PA9);

unsigned long time_uptime_ms(){
  return millis();
}


void lock_cb(bool caps_changed, bool num_changed)
{
  bool do_int = false;

  if (caps_changed && reg_is_bit_set(REG_ID_CFG, CFG_CAPSLOCK_INT)) {
    reg_set_bit(REG_ID_INT, INT_CAPSLOCK);
    do_int = true;
  }

  if (num_changed && reg_is_bit_set(REG_ID_CFG, CFG_NUMLOCK_INT)) {
    reg_set_bit(REG_ID_INT, INT_NUMLOCK);
    do_int = true;
  }


  /* // int_pin can be a LED 
  if (do_int) {
    port_pin_set_output_level(int_pin, 0);
    delay_ms(INT_DURATION_MS);
    port_pin_set_output_level(int_pin, 1);
  }*/
  
}


static void key_cb(char key, enum key_state state)
{
  bool do_int = false;

  if (reg_is_bit_set(REG_ID_CFG, CFG_KEY_INT)) {
    reg_set_bit(REG_ID_INT, INT_KEY);
    do_int = true;
  }

#ifdef DEBUG
  //Serial1.println("key: 0x%02X/%d/%c, state: %d, blk: %d\r\n", key, key, key, state, reg_get_value(REG_ID_BKL));
#endif

  const struct fifo_item item = { key, state };
  if (!fifo_enqueue(item)) {
    if (reg_is_bit_set(REG_ID_CFG, CFG_OVERFLOW_INT)) {
      reg_set_bit(REG_ID_INT, INT_OVERFLOW);//INT_OVERFLOW  The interrupt was generated by FIFO overflow.
      do_int = true;
    }

    if (reg_is_bit_set(REG_ID_CFG, CFG_OVERFLOW_ON))
      fifo_enqueue_force(item);
  }

  Serial1.println(key);
  
}


//---------------------------------------
void requestEvent()
{
  //if keys pressed ,then Wire.write(xxxx); 
  const struct fifo_item item = fifo_dequeue();
  if (item.key!= 0) {
    Wire.write(item.key);
  }
}

void setup() {

  pinMode(PA13, OUTPUT);//pico enable
  delay(100);
  digitalWrite(PA13, HIGH);   
  
  pinMode(PC13, OUTPUT);// indicator led
  delay(100);
  digitalWrite(PC13, LOW);   



  int pin = PC8;

  /*
  RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
  // 重映射Timer3的部分映射到PC6-PC9
  AFIO->MAPR &= ~AFIO_MAPR_TIM3_REMAP;
  AFIO->MAPR |= AFIO_MAPR_TIM3_REMAP_PARTIALREMAP;
  */
  /*
  pinMode(pin,OUTPUT);
  
  TIM_TypeDef *Instance = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(pin), PinMap_PWM);
  uint32_t channel = STM_PIN_CHANNEL(pinmap_function(digitalPinToPinName(pin), PinMap_PWM));
  // Instantiate HardwareTimer object. Thanks to 'new' instantiation, HardwareTimer is not destructed when setup() function is finished.
  HardwareTimer *MyTim = new HardwareTimer(Instance);

  // Configure and start PWM
  // MyTim->setPWM(channel, pin, 5, 10, NULL, NULL); // No callback required, we can simplify the function call
  MyTim->setPWM(channel, pin, 80000, 1); // Hertz, dutycycle 
  */
  /*
   * data records:
   * 500,10  === nightlight watch level
   */
  /*
  analogWriteFrequency(80000); 
  analogWrite(pin, 10); 
  */
  
  pin = PA8;
  analogWriteFrequency(10000); 
  analogWrite(pin, 100); 
  
  Wire.begin(0x5f);
  Wire.onRequest(requestEvent);

  Serial1.begin(115200); 

  
  reg_init();
  
  keyboard_init();
  keyboard_set_key_callback(key_cb);
  
  printf("Start pico");
}

void loop() {

  keyboard_process();
}
