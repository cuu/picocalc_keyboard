#include <Arduino.h>

#include <Wire.h>
//---------------------------------------
#include "conf_app.h"

#include "pins.h"
#include "reg.h"
#include "port.h"
#include "fifo.h"
#include "keyboard.h"


#define DEBUG_UART

HardwareSerial Serial1(PA10, PA9);

uint8_t write_buffer[2];
  
unsigned long time_uptime_ms(){
  return millis();
}


void lock_cb(bool caps_changed, bool num_changed)
{
  bool do_int = false;

  if (caps_changed && reg_is_bit_set(REG_ID_CFG, CFG_CAPSLOCK_INT)) {
    reg_set_bit(REG_ID_INT, INT_CAPSLOCK);
    do_int = true;
  }

  if (num_changed && reg_is_bit_set(REG_ID_CFG, CFG_NUMLOCK_INT)) {
    reg_set_bit(REG_ID_INT, INT_NUMLOCK);
    do_int = true;
  }


  /* // int_pin can be a LED 
  if (do_int) {
    port_pin_set_output_level(int_pin, 0);
    delay_ms(INT_DURATION_MS);
    port_pin_set_output_level(int_pin, 1);
  }*/
  
}


static void key_cb(char key, enum key_state state)
{
  bool do_int = false;

  if (reg_is_bit_set(REG_ID_CFG, CFG_KEY_INT)) {
    reg_set_bit(REG_ID_INT, INT_KEY);
    do_int = true;
  }

#ifdef DEBUG
  //Serial1.println("key: 0x%02X/%d/%c, state: %d, blk: %d\r\n", key, key, key, state, reg_get_value(REG_ID_BKL));
#endif

  const struct fifo_item item = { key, state };
  if (!fifo_enqueue(item)) {
    if (reg_is_bit_set(REG_ID_CFG, CFG_OVERFLOW_INT)) {
      reg_set_bit(REG_ID_INT, INT_OVERFLOW);//INT_OVERFLOW  The interrupt was generated by FIFO overflow.
      do_int = true;
    }

    if (reg_is_bit_set(REG_ID_CFG, CFG_OVERFLOW_ON))
      fifo_enqueue_force(item);
  }

  Serial1.println(key);
  
}

void receiveEvent(int howMany)
{
  
  uint8_t rcv_data[2];//max size 2, protocol defined
  uint8_t rcv_idx;

  if(Wire.available() < 1) return;
 
  rcv_idx =0;
  while(Wire.available()) // loop through all but the last
  {
    uint8_t c = Wire.read(); // receive byte as a character
    rcv_data[rcv_idx] = c;
    rcv_idx++;
    if(rcv_idx>=2){
      rcv_idx = 0;
    }
  }

  const bool is_write = (rcv_data[0] & WRITE_MASK);
  const uint8_t reg = (rcv_data[0] & ~WRITE_MASK);

  switch(reg){
    case REG_ID_FIF:{
        const struct fifo_item item = fifo_dequeue();
        write_buffer[0] = (uint8_t)item.state;
        write_buffer[1] = (uint8_t)item.key;
    }
        break;
    default:
    {
      write_buffer[0] = 0;
      write_buffer[1] = 0;
    }
      break;     
  }

}


//-thi is after receiveEvent-------------------------------
void requestEvent()
{

  Wire.write(write_buffer,2);

}

void setup() {

  Wire.setSDA(PB9);
  Wire.setSCL(PB8);
  Wire.begin(SLAVE_ADDRESS);
  Wire.setClock(100000);//must be as same as master(pico,Option.SYSTEM_I2C_SLOW=1;)
  Wire.onReceive(receiveEvent); // register event
  Wire.onRequest(requestEvent);
  
  pinMode(PA13, OUTPUT);//pico enable
  delay(100);
  digitalWrite(PA13, HIGH);   
  
  pinMode(PC13, OUTPUT);// indicator led
  delay(100);
  digitalWrite(PC13, LOW);   



  int pin = PC8;

  /*
  RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
  // 重映射Timer3的部分映射到PC6-PC9
  AFIO->MAPR &= ~AFIO_MAPR_TIM3_REMAP;
  AFIO->MAPR |= AFIO_MAPR_TIM3_REMAP_PARTIALREMAP;
  */
  /*
  pinMode(pin,OUTPUT);
  
  TIM_TypeDef *Instance = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(pin), PinMap_PWM);
  uint32_t channel = STM_PIN_CHANNEL(pinmap_function(digitalPinToPinName(pin), PinMap_PWM));
  // Instantiate HardwareTimer object. Thanks to 'new' instantiation, HardwareTimer is not destructed when setup() function is finished.
  HardwareTimer *MyTim = new HardwareTimer(Instance);

  // Configure and start PWM
  // MyTim->setPWM(channel, pin, 5, 10, NULL, NULL); // No callback required, we can simplify the function call
  MyTim->setPWM(channel, pin, 80000, 1); // Hertz, dutycycle 
  */
  /*
   * data records:
   * 500,10  === nightlight watch level
   */
  /*
  analogWriteFrequency(80000); 
  analogWrite(pin, 10); 
  */
  
  pin = PA8;
  analogWriteFrequency(10000); 
  analogWrite(pin, 100); 
  
  //Wire.onRequest(requestEvent);

  Serial1.begin(115200); 

  
  reg_init();
  
  keyboard_init();
  keyboard_set_key_callback(key_cb);
  
  printf("Start pico");
}

void loop() {

  keyboard_process();
}
